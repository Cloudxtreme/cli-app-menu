# Â©2013 Copyright 2013 Robert D. Chin
#
# +----------------------------------------+
# |             Revision Date              |
# +----------------------------------------+
# REVDATE="November-05-2013 19:02"
#
# +----------------------------------------+
# |        Function f_menu_cat_system      |
# +----------------------------------------+
#
#  Inputs: None.
#    Uses: BSY, MENU_ITEM, MAX
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_cat_system () {
      f_initvars_menu_app "BSY"
      until [ "$BSY" = "0" ]
      do    # Start of System Application Category until loop.
#f_menu_app_sys_backup #BSY Backup      - File Backup.
#f_menu_app_sys_disks #BSY Disks       - Disk information.
#f_menu_app_sys_health #BSY Health      - Anti-virus scanners, root-kit detectors, stress tests etc.
#f_menu_app_sys_logs #BSY Logs        - Log file viewers, command line history.
#f_menu_app_sys_mainboard #BSY Mainboard   - Information on PC mainboard, memory, etc.
#f_menu_app_sys_monitors #BSY Monitors    - Resources, and disk I/O monitors.
#f_menu_app_sys_other #BSY Other       - Screen capture, DOS and Nintendo Emulators, etc.
#f_menu_app_sys_peripherals #BSY Peripherals - Information on PC peripherals, PCI devices, hard drives, etc.
#f_menu_app_sys_process #BSY Process     - System process monitoring, killing.
#f_menu_app_sys_screens #BSY Screens     - Multiple screen sessions and terminal emulators.
#f_menu_app_sys_software #BSY Software    - (Un)Install and manage software packages (programs).
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Category Menu"
            DELIMITER="#BSY" #BSY This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read BSY
            f_menu_item_process $BSY  # Outputs $MENU_ITEM.
      done  # End of System Application Category until loop.
            #
      unset BSY MENU_ITEM  # Throw out this variable.
} # End of function f_menu_cat_system
#
# +----------------------------------------+
# |     Function f_menu_app_sys_backup     |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSB, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_backup () {
      f_initvars_menu_app "MSB"
      until [ "$MSB" = "0" ]
      do    # Start of Backup Applications until loop.
#0^0^0^0^1 #MSB dtrx  - Use tar without remembering which flags for each file to use.
#0^0^0^0^1 #MSB rsync - File backup, mirror, directories and files.
#0^0^0^0^1 #MSB tar   - File backup, compress files.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="Backup/Archive Applications Menu"
            DELIMITER="#MSB" #MSB This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSB
            f_menu_item_process $MSB  # Outputs $MENU_ITEM.
      done  # End of Backup Applications until loop.
            #
      unset MSB MENU_ITEM  # Throw out this variable.
} # End of function f_menu_app_sys_backup
#
# +----------------------------------------+
# |      Function f_menu_app_sys_disks     |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSD, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_disks () {
      f_initvars_menu_app "MSD"
      until [ "$MSD" = "0" ]
      do    # Start of System Disks Information Applications until loop.
#0^0^0^0^1 #MSD agedu  - Find wasted disk space.
#0^0^0^0^1 #MSD blkid  - Block devices.
#0^0^0^1^0 #MSD cfdisk - Disk partition tool.
#1^0^0^0^1 #MSD df     - Disk usage and mount points, usage: 'df -hT'.
#0^0^0^0^1 #MSD dfc    - Disk usage and mount points, graphical display.
#0^0^0^0^1 #MSD di     - 'df'-like disk usage utility.
#0^0^0^0^1 #MSD discus - 'df'-like disk usage utility with color, graphs, formatting.
#1^0^0^0^1 #MSD du     - Disk usage monitor by directory.
#0^0^0^1^0 #MSD gt5    - A diff-capable du-browser.
#0^0^0^0^1 #MSD hdparm - Show/set disk parameters, settings. 
#0^0^0^0^1 #MSD lsblk  - List block devices (disks).
#0^0^0^1^0 #MSD ncdu   - Disk usage monitor, ncurses-based.
#0^0^0^1^0 #MSD parted - Disk partition tool.
#1^0^0^0^1 #MSD pydf   - Disk usage df clone written in python.
#0^0^0^0^1 #MSD tdu    - Tree-view of disk space utilization; ncurses-based.
#1^0^0^0^1 #MSD uuid   - Use ls -l to show disk uuid number.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Disks Information Menu"
            DELIMITER="#MSD" #MSD This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER"
            read MSD
            f_menu_item_process $MSD  # Outputs $MENU_ITEM.
      done  # End of System Disks Information Applications until loop.
            #
      unset MSD MENU_ITEM  # Throw out this variable.
} # End of function f_menu_app_sys_disks
#
# +----------------------------------------+
# |              Function f_df             |
# +----------------------------------------+
#
f_df () {
       clear # Blank the screen.
       echo "df - Displays free space on disk"
       echo
       echo "Usage:"
       echo "df [OPTION]... [FILE]..."
       echo "df [OPTION]... --files0-from=F"
       echo "   -h, --human-readable    format (e.g., 1K 234M 2G)"
       echo "   --total                 produce a grand total"
       echo "   -t, --type=TYPE         limit listing to specific file systems"
       echo "   -T, --print-type        print file system type"
       echo "   -x, --exclude-type=TYPE limit listing to file systems not of type TYPE"
       echo
       echo "*** For more help type: 'man df'"
       echo "                        'df --help'"
       echo
       echo "Display total disk usage in human-readable format."
       echo
       echo "Now run du. Usage: df -hT"
       APP_NAME="df -hT"
       f_press_enter_key_to_continue
} # End of function f_df
#
# +----------------------------------------+
# |              Function f_du             |
# +----------------------------------------+
#
f_du () {
       clear # Blank the screen.
       echo "du - Displays disk usage per directory"
       echo
       echo "Usage:"
       echo "du [OPTION]... [FILE]..."
       echo "du [OPTION]... --files0-from=F"
       echo "   -h, --human-readable  human-readable format (e.g., 1K 234M 2G)"
       echo "   -c, --total           produce a grand total"
       echo "   -S, --separate-dirs   do not include sub-folders"
       echo "   -s, --summarize       display only a total"
       echo "   --exclude=PATTERN     exclude files matching PATTERN"
       echo "   -d, --max-depth=N     N  or  fewer  levels  below"
       echo
       echo "*** For more help type: 'man du'"
       echo "                        'du --help'"
       echo
       echo "Display total disk usage in human-readable format."
       echo
       echo "Now run du. Usage: du -hsc"
       APP_NAME="du -hsc"
       f_press_enter_key_to_continue
} # End of function f_du
#
# +----------------------------------------+
# |             Function f_pydf            |
# +----------------------------------------+
#
f_pydf () {
       clear # Blank the screen.
       echo "pydf - Displays free space on disk"
       echo
       echo "Usage:"
       echo "pydf [OPTION]... [FILE]..."
       echo "   -h, --human-readable    format (e.g., 1K 234M 2G)"
       echo "   -k, --kilobytes"
       echo "   -m, --megabytes"
       echo "   -g, --gigabytes"
       echo
       echo "*** For more help type: 'man df'"
       echo "                        'df --help'"
       echo
       echo "Display total disk usage in human-readable format."
       echo
       echo "Now run df. Usage: pydf -hT"
       APP_NAME="pydf -hT"
       f_press_enter_key_to_continue
} # End of function f_pydf
#
# +----------------------------------------+
# |             Function f_uuid            |
# +----------------------------------------+
#
f_uuid () {
       clear # Blank the screen.
       echo "To find the UUID of a disk, type: ls -l /dev/disk/by-uuid."
       APP_NAME="ls -l /dev/disk/by-uuid"
       f_application_run             
       f_press_enter_key_to_continue
} # End of function f_uuid
#
# +----------------------------------------+
# |     Function f_menu_app_sys_health     |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSH, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_health () {
      f_initvars_menu_app "MSH"
      until [ "$MSH" = "0" ]
      do    # Start of System Health Applications until loop.
#0^0^0^0^1 #MSH aide       - Advanced Intrusion Detection Environment check file integrity.
#1^0^0^0^1 #MSH arp-scan   - Discover, fingerprint hosts on LAN using MAC addresses.
#0^0^0^0^1 #MSH arpalert   - Checks MAC addresses against list of known MACs, runs script.
#0^0^0^0^1 #MSH arpon      - ArpON detects/blocks arp poisoning/spoofing attacks.
#1^0^0^0^1 #MSH arpwatch   - Detects unknown MAC addresses and IP addresses, like ArpON.
#0^0^0^0^1 #MSH chkrootkit - Root Kit detector.
#1^0^0^0^1 #MSH clamscan   - Clam anti-virus program scans for viruses.
#0^0^0^0^1 #MSH cpuburn    - Stress test puts heavy loads on a CPU.
#0^0^0^1^1 #MSH freshclam  - Clam anti-virus database definition update.
#0^0^0^0^1 #MSH lynis      - security auditing tool that tests for security holes in a PC.
#0^0^0^0^1 #MSH rkhunter   - Root Kit detector.
#1^0^0^0^1 #MSH tripwire   - Detects/Reports changes in system files.
#1^0^0^0^1 #MSH stress     - Stress test can simulate a heavy load on CPU.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Health Applications Menu"
            DELIMITER="#MSH" #MSH This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSH
            f_menu_item_process $MSH  # Outputs $MENU_ITEM.
      done  # End of System Health Applications until loop.
            #
      unset MSH MENU_ITEM  # Throw out this variable.
} # End of function f_menu_app_sys_health
#
# +----------------------------------------+
# |           Function f_arp-scan          |
# +----------------------------------------+
#
f_arp-scan () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "arp-scan - ARP Scanner."
         echo
         echo "Usage:"
         echo "arp-scan [OPTIONS] [HOSTS]..."
         echo
         echo "       --localnet or -l"
         echo "              Generate addresses from network  interface  configuration.   Use"
         echo "              the  network  interface  IP address and network mask to generate"
         echo "              the list of target host addresses.  The list  will  include  the"
         echo "              network  and  broadcast  addresses,  so  an interface address of"
         echo "              10.0.0.1 with netmask 255.255.255.0 would  generate  256  target"
         echo "              hosts  from  10.0.0.0  to 10.0.0.255 inclusive."
         echo
         echo "       --interface=<s> or -I <s>"
         echo "              Use  network  interface  <s>."
         echo
         echo "Now run arp-scan on this PC as an example."
         echo "Usage: arp-scan -I <interface>"
         echo
         f_press_enter_key_to_continue
         f_find_NIC
         APP_NAME="arp-scan -I $ANS"
      fi
} # End of function f_arp-scan
#
# +----------------------------------------+
# |           Function f_arpwatch          |
# +----------------------------------------+
#
f_arpwatch () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "arpwatch - Keep track of ethernet/ip address pairings"
         echo
         echo "Arpwatch  keeps  track  for  ethernet/ip  address  pairings. It syslogs"
         echo "activity and reports certain changes via email.  Arpwatch uses  pcap(3)"
         echo "to listen for arp packets on a local ethernet interface."
         echo
         echo "Usage:"
         echo "arpwatch [-dN] [-f datafile] [-i interface] [-n net[/width]] [-r file]"
         echo "         [-s sendmail_path] [-p] [-a] [-m addr] [-u username]"
         echo "         [-R seconds ] [-Q] [-z ignorenet/ignoremask]"
         echo
         echo "Now run man arpwatch. Usage: man arpwatch"
         echo
         APP_NAME="man arpwatch"
         f_press_enter_key_to_continue
      fi
} # End of function f_arpwatch
#
# +----------------------------------------+
# |           Function f_clamscan          |
# +----------------------------------------+
#
f_clamscan () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "clamscan -  Anti-virus scanner"
         echo
         echo "Usage:" 
         echo "clamscan [OPTIONS] [FILE/DIRECTORY/-]"
         echo "         --recursive -r  will recursively scan a directory."
         echo "         --verbose   -v  be verbose."
         echo "         --infected  -i  only print infected files."
         echo "         --bell          sound bell on virus detection."
         echo
         echo "*** For more help type: 'man clamscan'"
         echo "                        'clamscan --help'"
         echo
         echo "Clam anti-virus will now scan the folder, please be patient"
         echo "since Clam anti-virus is slow to scan, but thorough."
         echo
         echo "Now run clamscan. Usage: clamscan -r ~"
         echo
         APP_NAME="clamscan -r ~"
         f_press_enter_key_to_continue
      fi
} # End of function f_clamscan
#
# +----------------------------------------+
# |            Function f_stress           |
# +----------------------------------------+
#
f_stress () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "stress - A tool to impose load on and stress test a computer system"
         echo
         echo "The application, 'stress' is a tool that imposes a configurable amount of CPU,"
         echo "memory, I/O, or disk stress on a POSIX-compliant operating system and reports"
         echo "any errors it detects."
         echo
         echo "The application 'stress' is not a benchmark."
         echo
         echo "It is a tool used by:"
         echo "System Administrators to evaluate how well their systems will scale,"
         echo "Kernel Programmers to evaluate perceived performance characteristics, and by"
         echo "Systems Programmers to expose the classes of bugs which only or more frequently"
         echo "manifest themselves when the system is under heavy load."
         echo
         echo "*** For more help type: 'man $APP_NAME'"
         echo "                '$APP_NAME --help'"
         echo
         f_press_enter_key_to_continue
      fi
} # End of function f_stress
#
# +----------------------------------------+
# |           Function f_tripwire          |
# +----------------------------------------+
#
f_tripwire () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "tripwire - Detects unauthorized file changes"
         echo
         echo "*** For more help type: 'man tripwire' for use and operation."
         echo "*** For more help type: 'man twadmin' - create, encode policy, config files."
         echo "*** For more help type: 'man twprint' - print database."
         echo "*** For more help type: 'man siggen' - display hash values for files."
         echo "*** For more help type: 'man twconfig' - explanation of config files."
         echo "*** For more help type: 'man twpolicy' - explanation of policy files."
         echo "*** For more help type: 'man twfiles' - overview of files, settings."
         echo
         echo "Usage:"
         echo "Database Initialization:  tripwire [-m i|--init] [OPTIONS]"
         echo "Integrity Checking:  tripwire [-m c|--check] [object1 [object2...]]"
         echo "Database Update:  tripwire [-m u|--update]"
         echo "Policy Update:  tripwire [-m p|--update-policy] policyfile.txt"
         echo "Test:  tripwire [-m t|--test] --email address"
         echo "Type 'tripwire [mode] --help' OR"
         echo "'tripwire --help mode [mode...]' OR"
         echo "'tripwire --help all' for extended help"
         echo
         echo "Now run man tripwire. Usage: man tripwire"
         echo
         APP_NAME="man tripwire"
         f_press_enter_key_to_continue
      fi
} # End of function f_tripwire
#
# +----------------------------------------+
# |      Function f_menu_app_sys_logs      |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MLO, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_logs () {
      f_initvars_menu_app "MLO"
      until [ "$MLO" = "0" ]
      do    # Start of System Logs until loop.
#0^0^0^0^1 #MLO ccze       - A robust and modular log colorizer, with plugins.
#0^0^0^0^1 #MLO colortail  - log colorizer.
#0^0^0^0^1 #MLO hash       - Show frequency of commands entered at the prompt.
#0^0^0^0^1 #MLO history    - Show history of commands entered at the prompt.
#0^0^0^0^1 #MLO inotail    - Tail command replacement uses the inotify API to re-read files.
#0^0^0^0^1 #MLO lnav       - View, analyze log files, histogram, hotkeys, ncurses-based.
#0^0^0^0^1 #MLO logtailer  - Monitor logs for updates and display them.
#0^0^0^0^1 #MLO monkeytail - tail variant designed for web developers monitoring logfiles.
#0^0^0^0^1 #MLO multitail  - View multiple log files using multiple panes.
#0^0^0^0^1 #MLO since      - Shows new changes in log files since last run. Tail work-alike.
#0^0^0^0^1 #MLO swatch     - Log file viewer with regexp matching, highlighting & hooks.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Logs Menu"
            DELIMITER="#MLO" #MLO This 3rd field prevents awk from printing this line into menu options.
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MLO
            f_menu_item_process $MLO  # Outputs $MENU_ITEM.
      done  # End of System Logs Applications until loop.
            #
      unset MLO MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_sys_logs
#
# +----------------------------------------+
# |   Function f_menu_app_sys_mainboard    |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSI, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_mainboard () {
      f_initvars_menu_app "MSI"
      until [ "$MSI" = "0" ]
      do    # Start of System Information until loop.
#0^0^0^0^1 #MSI dmidecode   - Main board information.
#1^0^0^0^1 #MSI free        - Memory usage RAM and swap.
#1^0^0^0^1 #MSI hdparm      - Hard disk drive information.
#1^0^0^0^1 #MSI lsb_release - Linux distro and LSB (Linux Standard Base).
#0^0^0^0^1 #MSI lscpu       - CPU information.
#1^0^0^0^1 #MSI lshw        - Main board information.
#0^0^0^0^1 #MSI lsmod       - Linux kernel module information.
#0^0^0^0^1 #MSI mbw         - "Copy" memory bandwidth available to userspace programs.
#1^0^0^1^0 #MSI slabtop     - Kernel slab cache information in real time.
#1^0^0^0^1 #MSI uname       - Linux kernel information.
#0^0^0^0^1 #MSI vmstat      - Memory usage RAM and swap, CPU information.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="Mainboard Information Menu"
            DELIMITER="#MSI" #MSI This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSI
            f_menu_item_process $MSI  # Outputs $MENU_ITEM.
      done  # End of Mainboard System Information Applications until loop.
            #
      unset MSI MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_sys_mainboard
#
# +----------------------------------------+
# |             Function f_free            |
# +----------------------------------------+
#
f_free () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "free - Display the amount of free and used memory both RAM and swap"
         echo
         echo "Usage:"
         echo "free [-b|-k|-m|-g] [-c count] [-l] [-o] [-t] [-s delay] [-V]"
         echo
         echo "*** For more help type: 'man free'"
         echo "                        'free --help'"
         echo
         echo "Display in MB Megabytes with column totals, for 5 times every 2 seconds."
         echo
         echo "Now run free. Usage: free -m -t -s 2 -c 5"
         APP_NAME="free -m -t -s 2 -c 5"
         f_press_enter_key_to_continue
      fi
} # End of f_free
#
# +----------------------------------------+
# |            Function f_hdparm           |
# +----------------------------------------+
#
f_hdparm () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "hdparm - Get SATA/IDE hard disk drive parameters."
         echo
         echo "Usage:"
         echo "hdparm [OPTIONS..] [DEVICE ...]"
         echo
         echo "*** For more help type: 'man hdparm'"
         echo "                'hdparm --help'"
         echo
         echo "Find information about the first hard disk drive: /dev/sda on this PC (localhost)."
         echo
         echo "Now run hdparm. Usage: 'hdparm -I /dev/sda'"
         APP_NAME="hdparm -I /dev/sda"
         f_press_enter_key_to_continue
      fi
} # End of f_hdparm
#
# +----------------------------------------+
# |          Function f_lsbrelease         |
# +----------------------------------------+
#
f_lsbrelease () {

      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "lsb_release - print distribution-specific information"
         echo "The  lsb_release command provides certain LSB (Linux Standard Base) and"
         echo "distribution-specific information."
         echo
         echo "Usage:" 
         echo "If no options are given, the -v option is assumed."
         echo
         echo "lsb_release [OPTIONS]"
         echo "            -v, --version   Version of lsb_release."
         echo "            -i, --id        Display the distributor's ID."
         echo "            -r, --release   Display the release number."
         echo "            -c, --codename  Display the code name of the currently installed"
         echo "                            distribution."
         echo "            -a, --all       Display all of the above information."
         echo
         echo "Now run lsb_release. Usage: 'lsb_release -a'"
         APP_NAME="lsb_release -a"
         f_press_enter_key_to_continue
      fi
} # End of f_lsbrelease
#
# +----------------------------------------+
# |             Function f_lshw            |
# +----------------------------------------+
#
f_lshw () {

      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "lshw - Displays main board information"
         echo
         echo "Usage:"
         echo "lshw [ -version ]"
         echo "lshw [ -help ]"
         echo "lshw [ -X ]"
         echo "lshw  [ -html ] [ -short ] [ -xml ] [ -json ] [ -businfo ] [ -dump filename ]"
         echo "[ -class class... ] [ -disable test... ] [ -enable test... ] [ -sanitize ]"
         echo "[ -numeric ] [ -quiet ]"
         echo
         echo "*** For more help type: 'man lshw'"
         echo "                'lshw --help'"
         echo
         echo "Display short report."
         echo
         echo "Now run lshw. Usage: lshw -short"
         echo
         echo "Please wait a few moments as the report is completed."
         APP_NAME="lshw -short"
         f_press_enter_key_to_continue
      fi
} # End of f_lshw
#
# +----------------------------------------+
# |            Function f_slabtop          |
# +----------------------------------------+
#
f_slabtop () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "slabtop - Display kernel slab cache information in real time."
         echo
         echo "slabtop displays a listing of the top caches sorted by  one  of  the  listed"
         echo "sort  criteria.   It also displays a statistics header filled with slab"
         echo "layer information."
         echo
         echo "Usage:"
         echo "slabtop [OPTIONS]"
         echo
         echo "slabtop  displays  detailed kernel slab cache information in real time."
         echo
         echo "*** For more help type: 'man slabtop'"
         echo "                        'slabtop --help'"
         echo
         echo "If you get error message: 'fopen /proc/slabinfo: Permission denied'"
         echo "Then try running with sudo command i.e. 'sudo slabtop'."
         echo
         f_press_enter_key_to_continue
      fi
} # End of f_slabtop
#
# +----------------------------------------+
# |             Function f_uname           |
# +----------------------------------------+
#
f_uname () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "uname - print system information"
         echo
         echo "Usage:" 
         echo "If no options are given, the -s option is assumed."
         echo
         echo "uname [OPTIONS]"
         echo "      -a, --all  print  all  information."
         echo "      -s, --kernel-name"
         echo "      -r, --kernel-release"
         echo "      -v, --kernel-version"
         echo "      -m, --machine    print the machine hardware name"
         echo "      -p, --processor"
         echo "      -i, --hardware-platform"
         echo "      -o, --operating-system"
         echo
         echo "Now run uname. Usage: uname -a"
         APP_NAME="uname -a"
         f_press_enter_key_to_continue
      fi
} # End of f_uname
#
# +----------------------------------------+
# |    Function f_menu_app_sys_monitors    |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSM, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_monitors () {
      f_initvars_menu_app "MSM"
      until [ "$MSM" = "0" ]
      do    # Start of System Monitors until loop.
#0^0^0^0^0 #MSM acpi      - Show acpi information.
#0^0^0^0^0 #MSM acpitail  - Show acpi information in growing tail list.
#0^0^0^0^1 #MSM atsar     - CPU, network, memory & disk I/O, record data for analysis.
#1^0^0^0^1 #MSM cacti     - Frontend to rrdtool for monitoring systems and services.
#1^0^0^0^1 #MSM chkconfig - System update/query run-level processes at boot time.
#0^0^0^1^0 #MSM conky-cli - Versatile, configurable system monitor.
#1^0^0^0^0 #MSM dstat     - View system resources, replaces vmstat, iostat, ifstat.
#0^0^0^1^0 #MSM glances   - View system processes/resources, CPU/Load/Mem/Swap/Disk/BW.
#0^0^0^0^1 #MSM iostat    - CPU usage and disk I/O process monitor.
#0^0^0^1^0 #MSM iotop     - Disk I/O process monitor.
#0^0^0^0^1 #MSM last      - Users' login/logout times from /var/log/wtmp.
#1^0^0^0^1 #MSM mpstat    - CPU microprocessor usage monitor.
#0^0^0^0^0 #MSM nmon      - CPU usage, memory, network, disk usage, processes, resources.
#0^0^0^0^0 #MSM rcconf    - Debian enable/disable startup scripts/services; ncurses-based.
#0^0^0^0^0 #MSM ntsysd    - RedHat view/enable/disable startup scripts/services.
#f_menu_app_sys_monitors2^0^0^0^1 #MSM MORE...   - For more system monitor applications.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Monitors Menu"
            DELIMITER="#MSM" #MSM This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSM
            f_menu_item_process $MSM  # Outputs $MENU_ITEM.
      done  # End of System Monitors Applications until loop.
            #
      unset MSM MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_sys_monitors
#
# +----------------------------------------+
# |    Function f_menu_app_sys_monitors2   |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSN, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_monitors2 () {
      f_initvars_menu_app "MSN"
      until [ "$MSN" = "0" ]
      do    # Start of System Monitors until loop.
#0^0^0^0^1 #MSN rrdtool      - Round Robin Database Tool stores/displays time-series data.
#0^0^0^1^0 #MSN saidar       - Monitor system processes, network I/O, disks I/O, free space.
#0^0^0^1^0 #MSN sysv-rc-conf - Debian view/enable/disable startup scripts/services.
#0^0^0^0^1 #MSN sar          - CPU usage statistics, user/nice/system/iowait/steal/idle.
#f_run_and_exit "tload" "tload"^0^0^0^1 #MSN tload        - System load average graphical monitor.
#0^0^0^0^1 #MSN ttyload      - Color-coded graphs of CPU load average.
#0^0^0^1^0 #MSN yacpi        - ACPI monitor, ncurses-based.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Monitors2 Menu"
            DELIMITER="#MSN" #MSN This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSN
            f_menu_item_process $MSN  # Outputs $MENU_ITEM.
      done  # End of System Monitors Applications until loop.
            #
      unset MSN MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_sys_monitors2
#
# +----------------------------------------+
# |             Function f_cacti           |
# +----------------------------------------+
#
f_cacti () {
      clear # Blank the screen.
      echo "cacti - Frontend to rrdtool for monitoring systems and services."
      echo
      echo "Cacti is a complete frontend to rrdtool, it stores all of the necessary"
      echo "information to create graphs and populates them with data in a MySQL"
      echo "database.  The frontend is completely PHP driven.  Along with being able"
      echo "to maintain Graphs, Data Sources, and Round Robin Archives in a"
      echo "database, cacti handles the data gathering also.  There is also SNMP"
      echo "support for those used to creating traffic graphs with MRTG."
      echo
      echo "This package requires a functional MySQL database server on either the"
      echo "installation host or remotely accessible system.  If you do not already"
      echo "have a database server available, you should also install mysql-server."
      echo
      echo "Homepage: http://www.cacti.net/"
      echo
      echo "*** For more help type: 'man cacti'"
      echo "                        'cacti --help'"
      echo
      APP_NAME="cacti"
      f_press_enter_key_to_continue
} # End of f_cacti
#
# +----------------------------------------+
# |           Function f_chkconfig         |
# +----------------------------------------+
#
f_chkconfig () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "chkconfig - Manipulate run-level services at boot time."
         echo
         echo "Usage:"
         echo "chkconfig -t|--terse [names]"
         echo "chkconfig -s|--set [name state]"
         echo "chkconfig -e|--edit [names]"
         echo "chkconfig -c|--check name [state]"
         echo "chkconfig -l|--list [--deps] [names]"
         echo "chkconfig -A|--allservices"
         echo "chkconfig -a|--add [names]"
         echo "chkconfig -d|--del [names]"
         echo
         echo "*** For more help type: 'man chkconfig'"
         echo "                        'chkconfig --help'"
         echo
         echo "Now run chkconfig. Usage: chkconfig -l"
         APP_NAME="chkconfig -l"
         f_press_enter_key_to_continue
      fi
} # End of f_chkconfig
#
# +----------------------------------------+
# |             Function f_dstat           |
# +----------------------------------------+
#
f_dstat () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "dstat - Display system resource statistics."
         echo
         echo "Usage:"
         echo "dstat [-afv] [OPTIONS..] [DELAY [COUNT]]"
         echo
         echo "*** For more help type: 'man dstat'"
         echo "                        'dstat --help'"
         echo
         echo "dstat this PC (localhost) for 10 times as an example."
         echo
         echo "Now run dstat. Usage: dstat 1 10"
         APP_NAME="dstat 1 10"
         f_press_enter_key_to_continue
      fi
} # End of f_dstat
#
# +----------------------------------------+
# |             Function f_mpstat          |
# +----------------------------------------+
#
f_mpstat () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "mpstat - Display CPU statistics."
         echo
         echo "Usage:"
         echo "mpstat [ -A ] [ -I { SUM | CPU | SCPU | ALL } ] [ -u ]"
         echo "[ -P { cpu [,...] | ON | ALL } ] [ -V ] [ interval [ count ] ]"
         echo
         echo "*** For more help type: 'man mpstat'"
         echo "                        'mpstat --help'"
         echo
         echo "mpstat this PC's CPU (localhost) for 5 times every 2 seconds as an example."
         echo
         echo "Now run mpstat. Usage: dstat 2 5"
         APP_NAME="mpstat 2 5"
         f_press_enter_key_to_continue
      fi
} # End of f_mpstat
#
# +----------------------------------------+
# |            Function f_rrdtool          |
# +----------------------------------------+
#
f_rrdtool () {
      clear # Blank the screen.
      echo "rrdtool   - The Round Robin Database Tool stores/displays time-series data."
      echo
      echo "The Round Robin Database Tool (RRDtool) is a system to store and display"
      echo "time-series data (e.g. network bandwidth, machine-room temperature,"
      echo "server load average). It stores the data in Round Robin Databases (RRDs),"
      echo "a very compact way that will not expand over time. RRDtool processes the"
      echo "extracted data to enforce a certain data density, allowing for useful"
      echo "graphical representation of data values."
      echo
      echo "RRDtool is often used via various wrappers that can poll data from devices"
      echo "and feed data into RRDs, as well as provide a friendlier user interface and"
      echo "customized graphs."
      echo
      echo "*** For more help type: 'man rrdtool'"
      echo "                        'rrdtool --help'"
      echo
      f_press_enter_key_to_continue
} # End of f_rrdtool
#
# +----------------------------------------+
# |     Function f_menu_app_sys_other      |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSO, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_other () {
      f_initvars_menu_app "MSO"
      until [ "$MSO" = "0" ]
      do    # Start of System Other until loop.
#0^0^0^0^1 #MSO apg       - Password generator that can specify a pattern.
#0^0^0^0^1 #MSO apropos   - Search linux man(ual) files for a forgotten command.
#0^0^0^0^1 #MSO colortest - Test color capabilities of a terminal.
#0^0^0^0^1 #MSO cpm       - Password manager using PGP-encryption, ncurses-based.
#0^0^0^0^1 #MSO desmume   - Nintendo DS emulator.
#0^0^0^0^1 #MSO dosemu    - DOS emulator.
#0^0^0^0^1 #MSO fbgrab    - Framebuffer screenshot tool.
#0^0^0^0^1 #MSO script    - Records terminal input/output (keystrokes).
#0^0^0^0^1 #MSO scrot     - Framebuffer screenshot tool.
#0^0^0^0^1 #MSO ttyrec    - Records terminal input/output and also timing-information.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="Other System Applications Menu"
            DELIMITER="#MSO" #MSO This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSO
            f_menu_item_process $MSO  # Outputs $MENU_ITEM.
      done  # End of Other System Applications until loop.
            #
      unset MSO MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_sys_other
#
# +----------------------------------------+
# |   Function f_menu_app_sys_peripherals  |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSL, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_peripherals () {
      f_initvars_menu_app "MSL"
      until [ "$MSL" = "0" ]
      do    # Start of Peripheral System Information until loop.
#0^0^0^0^1 #MSL acpitool  - ACPI power/battery settings.
#1^0^0^0^1 #MSL blkid     - Block devices information.
#0^0^0^0^1 #MSL cdde      - Detects if a CD is inserted, runs specified program.
#0^0^0^0^1 #MSL inxi      - Show model/make, CPU, graphics, audio, network, HDD, etc.
#0^0^0^0^1 #MSL lsblk     - List block devices (disks).
#0^0^0^0^1 #MSL lsof      - Display information about open files.
#1^0^0^0^1 #MSL lspci     - PCI buses and connected devices.
#0^0^0^0^1 #MSL lspcmcia  - PCMCIA extended debugging information.
#0^0^0^0^1 #MSL lsusb     - USB devices.
#1^0^0^0^1 #MSL pccardctl - PCMCIA card devices.
#0^0^0^0^1 #MSL printenv  - Environmental variables.
#0^0^0^0^1 #MSL scanimage - Control flatbed scanners, cameras. -L list of devices.
#0^0^0^0^1 #MSL setcd     - Control CDROM device, auto-close/eject/locking, set speed.
#0^0^0^0^1 #MSL uptime    - Display how long PC has been running, # users, load average.
#0^0^0^0^1 #MSL w         - A combination of uptime and who commands.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="Peripheral System Information Menu"
            DELIMITER="#MSL" #MSL This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSL
            f_menu_item_process $MSL  # Outputs $MENU_ITEM.
      done  # End of Peripheral System Information Applications until loop.
            #
      unset MSL MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_sys_peripherals
#
# +----------------------------------------+
# |             Function f_blkid           |
# +----------------------------------------+
#
f_blkid () {
      clear # Blank the screen.
      echo "blkid - Locate/print block device attributes"
      echo
      echo "The blkid program is the command-line interface to working with the libblkid(3)"
      echo "library.  It can determine the type of content (e.g. filesystem or swap) that a"
      echo "block device holds, and also attributes (tokens, NAME=value pairs) from the"
      echo "content metadata (e.g. LABEL or UUID fields)."
      echo
      echo "blkid has two main forms of operation: either searching for a device with a"
      echo "specific NAME=value pair, or displaying NAME=value pairs  for  one  or more"
      echo "specified devices."
      echo
      echo "Usage:"
      echo "blkid -L label | -U uuid"
      echo "blkid [-dghlv] [-c file] [-w file] [-o format] [-s tag] [-t NAME=value][device]"
      echo "blkid -p [-O offset] [-S size] [-o format] [-s tag] [-n list] [-u list] device"
      echo "blkid -i [-o format] [-s tag] device ..."
      echo
      echo "*** For more help type: 'man blkid'"
      echo "                        'blkid --help'"
      echo
      f_press_enter_key_to_continue
} # End of f_blkid
#
# +----------------------------------------+
# |            Function f_lspcmcia         |
# +----------------------------------------+
#
f_lspcmcia () {
      clear # Blank the screen.
      echo "lspcmcia - Display extended PCMCIA debugging information."
      echo
      echo "lspcmcia is an alias for pccardctl ls, provided for convenience."
      echo
      echo "Usage:"
      echo "lspcmcia [-V] [-v ...] [socket]"
      echo
      echo "*** For more help type: 'man lspcmcia'"
      echo "                        'lspcmcia --help'"
      echo
      f_press_enter_key_to_continue
} # End of f_lspcmcia
#
# +----------------------------------------+
# |            Function f_pccardctl        |
# +----------------------------------------+
#
f_pccardctl () {
      clear # Blank the screen.
      echo "pccardctl - PCMCIA card control utility."
      echo
      echo "pccardctl  is  used  to monitor and control the state of PCMCIA sockets."
      echo "If a socket number is specified, the command will be applied to just one"
      echo "socket; otherwise, all sockets will be affected."
      echo
      echo "If pccardctl is executed by root, all commands are available."
      echo "If it is executed by an unpriviledged user, only the informational commands"
      echo "are accessible."
      echo
      echo "Usage:"
      echo "pccardctl [-V] [-v ...] command [socket]"
      echo
      echo "*** For more help type: 'man pccardctl'"
      echo "           'pccardctl --help'"
      f_press_enter_key_to_continue
} # End of f_pccardctl
#
# +----------------------------------------+
# |     Function f_menu_app_sys_process    |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSR, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_process () {
      f_initvars_menu_app "MSR"
      until [ "$MSR" = "0" ]
      do    # Start of System Process Applications until loop.
#0^0^0^1^0 #MSR atop      - View system processes/resources, CPU/Mem/Swap/Page/Disk/Net.
#0^0^0^3^0 #MSR htop      - View system processes/resources; bar graph of CPU/Mem/Swap.
#0^0^0^0^1 #MSR killall   - Kill processes based on full-name of process.
#0^0^0^0^1 #MSR pgrep     - Search ps output for full/partial name of process.
#1^0^0^0^1 #MSR pidstat   - View system processes/resources, PID/USR/System/Guest/CPU/Cmd.
#0^0^0^0^1 #MSR pkill     - Kill processes based on partial name of process.
#0^0^0^0^1 #MSR pmap      - View process memory usage.
#0^0^0^0^1 #MSR powertop  - Find software components which consume the most power.
#0^0^0^0^1 #MSR ps        - View system processes/resources, PID/PGID/SID/TTY/Time/Cmd.
#0^0^0^0^1 #MSR pstree    - Tree view system processes/resources, like "ps" command.
#0^0^0^0^1 #MSR pswatcher - Execute commands when certain processes are run.
#0^0^0^0^1 #MSR pwdx      - Report current working directory of a process.
#0^0^0^0^1 #MSR strace    - Trace process system calls and signals.
#0^0^0^0^1 #MSR sysctl    - Configure kernel parameters at runtime.
#0^0^0^1^0 #MSR top       - View system PID/User/PR/NI/VERT/RES/SHR/CPU/MEM/Time/Cmd.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Process Applications Menu"
            DELIMITER="#MSR" #MSR This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSR
            f_menu_item_process $MSR  # Outputs $MENU_ITEM.
      done  # End of System Process Applications until loop.
            #
      unset MSR MENU_ITEM  # Throw out this variable.
} # End of function f_menu_app_sys_process
#
# +----------------------------------------+
# |             Function f_pidstat         |
# +----------------------------------------+
#
f_pidstat () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "pidstat - View system processes/resources, PID/USR/System/Guest/CPU/Cmd."
         echo
         echo "pidstat this PC's CPU (localhost) for 3 times every 2 seconds as an example."
         echo
         echo "*** For more help type: 'man pidstat'"
         echo "                        'pidstat --help'"
         echo
         echo "Now run pidstat. Usage: pidstat 2 3"
         APP_NAME="pidstat 2 3"
         f_press_enter_key_to_continue
      fi
} # End of f_pidstat
#
# +----------------------------------------+
# |              Function f_ps             |
# +----------------------------------------+
#
f_ps () {
      if [[ ! "$APP_NAME" == *" "* ]] ; then
         clear # Blank the screen.
         echo "ps - View system processes/resources, PID/PGID/SID/TTY/Time/Cmd."
         echo
         echo "Usage:"
         echo "To see every process on the system using standard syntax:"
         echo "[ps -e ] [ ps -ef ] [ ps -eF ] [ ps -ely ]"
         echo
         echo "To see every process on the system using BSD syntax:"
         echo "[ ps ax] [ ps axu ]"
         echo
         echo "To print a process tree:"
         echo "[ ps -ejH ] [ ps axjf ]"
         echo
         echo "To get info about threads:"
         echo "[ ps -eLf ] [ ps axms ]"
         echo
         echo "To see every process running as root (real & effective ID) in user format:"
         echo "[ ps -U root -u root u ]"
         echo
         echo "*** For more help type: 'man ps'"
         echo "                        'ps --help'"
         echo
         echo "Now run ps. Usage: ps -ejH"
         APP_NAME="ps -ejH"
         f_press_enter_key_to_continue
      fi
} # End of f_ps
#
# +----------------------------------------+
# |          Function f_pswatcher          |
# +----------------------------------------+
#
f_pswatcher () {
      clear # Blank the screen.
      echo "pswatcher - Monitor a system via ps-like commands."
      echo
      echo "This program runs the ps command periodically and triggers commands on matches."
      echo "The match patterns are Perl regular expressions which can refer to the process"
      echo "information via variables."
      echo "For example it can be used to ensure that a daemon is running, or is not"
      echo "running too many times. It can also be used to determine when a process has"
      echo "consumed too many resources, perhaps due to a memory leak."
      echo "Homepage: http://ps-watcher.sourceforge.net/"
      echo
      echo "*** For more help type: 'man $APP_NAME'"
      echo "                        '$APP_NAME --help'"
      echo
      f_press_enter_key_to_continue
} # End of f_pswatcher
#
# +----------------------------------------+
# |            Function f_sysctl           |
# +----------------------------------------+
#
f_sysctl () {
      clear # Blank the screen.
      echo "sysctl - Configure kernel parameters at runtime."
      echo
      echo "sysctl is used to modify kernel parameters at runtime."
      echo "The parameters available are those listed under /proc/sys/."
      echo "Procfs is required for sysctl support in Linux.  You can use sysctl to both"
      echo "read and write sysctl data."
      echo
      echo "Usage:"
      echo "       sysctl [-n] [-e] variable ..."
      echo "       sysctl [-n] [-e] [-q] -w variable=value ..."
      echo "       sysctl [-n] [-e] [-q] -p [filename]"
      echo "       sysctl [-n] [-e] -a"
      echo "       sysctl [-n] [-e] -A"
      echo
      echo "EXAMPLES"
      echo "       /sbin/sysctl -a"
      echo "       /sbin/sysctl -n kernel.hostname"
      echo "       /sbin/sysctl -w kernel.domainname='example.com'"
      echo "       /sbin/sysctl -p /etc/sysctl.conf"
      echo
      echo "*** For more help type: 'man $APP_NAME'"
      echo "                        '$APP_NAME --help'"
      f_press_enter_key_to_continue
} # End of f_sysctl
#
# +----------------------------------------+
# |    Function f_menu_app_sys_screens     |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSC, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_screens () {
      f_initvars_menu_app "MSC"
      until [ "$MSC" = "0" ]
      do    # Start of System Screens until loop.
#0^0^0^0^0 #MSC away     - Locks terminal with password and checks for new email.
#0^0^0^0^0 #MSC byobu    - Multiple sessions.
#0^0^0^0^0 #MSC dtach    - Emulates detach feature of screen.
#0^0^0^0^0 #MSC dvtm     - dwm-style (tiling) window manager.
#0^0^0^0^0 #MSC fbterm   - Fast terminal emulator, multiple fonts, multiple windows.
#1^0^0^0^0 #MSC screen   - Multiple sessions via split or pager screens.
#f_screen^0^0^0^0 #MSC screenie - 'Screen' wrapper featuring a menu to manage detached jobs.
#1^0^0^0^0 #MSC splitvt  - Multiple sessions on horizontal split screen (vt100 compatible).
#0^0^0^0^0 #MSC tmux     - Multiple sessions with multiplexing.
#0^0^0^0^0 #MSC twin     - A text mode window environment for multiple windows on screen.
#0^0^0^0^0 #MSC vlock    - Locks virtual console or current terminal.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Screens Menu"
            DELIMITER="#MSC" #MSC This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSC
            f_menu_item_process $MSC  # Outputs $MENU_ITEM.
      done  # End of System Screens Applications until loop.
            #
      unset MSC MENU_ITEM  # Throw out this variable.
} # End of f_menu_app_sys_screens
#
# +----------------------------------------+
# |            Function f_screen           |
# +----------------------------------------+
#
f_screen () {
      clear # Blank the screen.
      echo "screen - Multiple screen-window sessions."
      echo 
      echo "Usage:"
      echo "<Ctrl>-A <double-quote> List all windows."
      echo "<Ctrl>-A N     Show window title."
      echo "<Ctrl>-A a     Name title of the window."
      echo
      echo "<Ctrl>-A c     Create new window."
      echo "<Ctrl>-A n     Switch to next window."
      echo "<Ctrl>-A p     Switch to previous window."
      echo "<Ctrl>-A l     Refresh window."
      echo "<Ctrl>-A <single-quote> Prompt window number to use."
      echo "<Ctrl>-A (0-9 or -)  Switch to window number to use."
      echo
      echo "<Ctrl>-A k     Kill window."
      echo "<Ctrl>-A S     Split window horizontally."
      echo "<Ctrl>-A <tab> Toggle between split window areas."
      echo "<Ctrl>-A x     Kill split window area."
      echo
      echo "*** For more help type: 'man screen'"
      echo "                        '$screen --help'"
      f_press_enter_key_to_continue
} # End of f_screen
#
# +----------------------------------------+
# |            Function f_splitvt          |
# +----------------------------------------+
#
f_splitvt () {
      clear # Blank the screen.
      echo "splitvt - Split screen horizontally into two upper/lower."
      echo
      echo "Usage:"
      echo "splitvt [OPTION]... [INPUT [PREFIX]]"
      echo
      echo "*** For more help type: 'man splitvt'" 
      echo "             'splitvt --help'"
      echo
      echo "Now run splitvt. Usage: splitvt"
      echo
      f_press_enter_key_to_continue
} # End of f_splitvt
#
# +----------------------------------------+
# |    Function f_menu_app_sys_software    |
# +----------------------------------------+
#
#  Inputs: None. 
#    Uses: MSF, MENU_ITEM, MAX.
# Outputs: ERROR, MENU_TITLE, DELIMITER.
#
f_menu_app_sys_software () {
      f_initvars_menu_app "MSF"
      until [ "$MSF" = "0" ]
      do    # Start of System Software Applications until loop.
#0^0^0^0^1 #MSF alien     - Converts rpm to deb packages.
#1^0^0^0^1 #MSF apt       - Debian package manager.
#0^0^0^0^1 #MSF apt-cache - Show package information, (reverse)/dependency information.
#0^0^0^0^1 #MSF apt-file  - Search/List files in the Debian package manager w/o installing.
#1^0^0^0^0 #MSF aptitude  - Debian package manager.
#0^0^0^0^1 #MSF aptoncd   - GUI makes a CD of Debian packages for installation w/o Internet.
#0^0^0^0^1 #MSF cupt      - Debian front-end to dpkg package manager.
#0^0^0^0^1 #MSF dpkg      - Debian package manager.
#0^0^0^0^1 #MSF rpm       - RPM (Red Hat) package manager.
#0^0^0^0^0 #MSF synaptic  - GUI Debian package manager.
#0^0^0^0^1 #MSF unshield  - Extracts CAB files from Microsoft-compatible InstallShield.
#0^0^0^0^1 #MSF urpmi     - Mandriva, Mageia package manager.
#0^0^0^0^1 #MSF YaST      - GUI OpenSUSE package manager.
#0^0^0^0^1 #MSF yum       - "Yellow Dog Updated" package manager.
#0^0^0^0^1 #MSF zypper    - OpenSUSE package manager on which is based YaST GUI.
            #
            THIS_FILE="mod_apps-system.lib"
            MENU_TITLE="System Software Applications Menu"
            DELIMITER="#MSF" #MSF This 3rd field prevents awk from printing this line into menu options. 
            #
            f_show_menu "$MENU_TITLE" "$DELIMITER" 
            read MSF
            f_menu_item_process $MSF  # Outputs $MENU_ITEM.
      done  # End of System Software Applications until loop.
            #
      unset MSF MENU_ITEM  # Throw out this variable.
} # End of function f_menu_app_sys_software
#
# +----------------------------------------+
# |              Function f_apt            |
# +----------------------------------------+
#
f_apt () {
                 APP_NAME="apt"
                 clear # Blank the screen.
                 echo "apt - Debian package manager."
                 echo
                 echo "Usage:"
                 echo "apt-cache showpkg <package name> Show package general information."
                 echo "apt-cache show <package name> Show package description and information."
                 echo "apt-cache depends <package name> Show package dependency information."
                 echo "apt-cache rdepends <package name> Show package reverse dependency information."
                 echo "apt-cache unmet <package name> Show package's unmet dependencies."
                 echo "apt-get check Check for broken dependencies."
                 echo "apt-get update Updates package information prior to updating or installing."
                 echo "apt-get upgrade Upgrade packages to latest versions."
                 echo "apt-get dist-upgrade Usually used after an 'apt-get upgrade' to upgrade kernel."
                 echo "apt-get install <package name> Installs a new software package."
                 echo "apt-get remove <package name> Uninstalls a software package."
                 echo "apt-get purge <package name> Uninstalls a package and its configuration files."
                 echo "apt-get autoclean Remove obsolete packages from the local repository."
                 echo "apt-get autoremove remove packages that are no longer needed."
                 echo
                 echo "*** For more help type: man apt / man apt-cache / man apt-get"
                 echo
                 f_press_enter_key_to_continue
} # End of function f_apt
#
# +----------------------------------------+
# |            Function f_aptitude         |
# +----------------------------------------+
#
f_aptitude () {
                 clear # Blank the screen.
                 echo "aptitude - Debian package manager."
                 echo 
                 echo "Usage:"
                 echo "aptitude [-S fname] [-u|-i]"
                 echo "aptitude [OPTIONS] <ACTION> ..."
                 echo 
                 echo "Options:"
                 echo " -h    This help text."
                 echo " -D    Show the dependencies of automatically changed packages."
                 echo " -v    Display extra information. (may be supplied multiple times)."
                 echo " -f    Aggressively try to fix broken packages."
                 echo  
                 echo "Actions (if none is specified, aptitude will enter interactive mode):"
                 echo "search    - Search for a package by name and/or expression."
                 echo "show      - Display detailed information about a package."
                 echo "install   - Install/upgrade packages."
                 echo "reinstall - Download and (possibly) reinstall a currently installed package."
                 echo "remove    - Remove packages."
                 echo "purge     - Remove packages and their configuration files."
                 echo "update    - Download lists of new/upgradable packages."
                 echo
                 echo "*** For more help type: man apt / man apt-cache / man apt-get"
                 f_press_enter_key_to_continue
} # End of function f_aptitude
#
# +----------------------------------------+
# |            Function f_aptoncd          |
# +----------------------------------------+
#
f_aptoncd () {
                 'aptoncd '* | 'sudo aptoncd '* | 'sudo aptoncd')
                 clear # Blank the screen.
                 echo "APTonCD - A GUI application and is in the menu for reference only."
                 echo
                 echo "However, like many GUI applications, it can be launched by from the CLI."
                 echo "APTonCD can be launched from the command line with the 'aptoncd' command."
                 echo
                 echo "APTonCD allows you to create an installation CD with all the debian packages"
                 echo "installed on the localhost PC from the /var/cache/apt/archives/ directory."
                 echo "It is one way to backup the software installed on your PC but such would"
                 echo "have to be reconfigured afterwards."
                 echo
                 echo "APTonCD is fully supported in Ubuntu and works in Debian Etch and Sid."
                 echo
                 f_press_enter_key_to_continue
} # End of function f_aptoncd
#
# +----------------------------------------+
# |              Function f_dpkg           |
# +----------------------------------------+
#
f_dpkg () {
                 clear # Blank the screen.
                 echo "dpkg - Debian package manager."
                 echo
                 echo "Usage:"
                 echo "dpkg --get-selections List all installed packages."
                 echo "dpkg-query -l <package name> Show package installation status."
                 echo "dpkg-query -p <package name> Show package description and information."
                 echo "dpkg -i <package name> Installs a new software package."
                 echo "dpkg -r <package name> Uninstalls a software package."
                 echo "dpkg -P <package name> Uninstalls a package and its configuration files."
                 echo
                 echo "*** For more help type: man dpkg / man dpkg-query"
                 echo
                 f_press_enter_key_to_continue
} # End of function f_dpkg
#
# +----------------------------------------+
# |              Function f_rpm            |
# +----------------------------------------+
#
f_rpm () {
                 clear # Blank the screen.
                 echo "rpm - RPM (Red Hat) package manager."
                 echo
                 echo "Usage:"
                 echo "rpm -q <package name> Show package description and information."
                 echo "rpm --query <package name> Show package description and information."
                 echo "rpm -U <package name> Upgrade/Install a package."
                 echo "rpm --upgrade <package name> Upgrade/Install a package."
                 echo "rpm -I <package name> Installs new software packages."
                 echo "rpm --install <package name> Installs new software packages."
                 echo "rpm -e <package name> Uninstalls software packages."
                 echo "rpm --erase <package name> Uninstalls software packages."
                 echo "rpm -V <package name> Verifies packages."
                 echo "rpm --verify <package name> Verifies packages."
                 echo "rpm -F <package name> Freshen (upgrade) installed packages."
                 echo "rpm --freshen<package name> Freshen (upgrade) installed packages."
                 echo "rpm --initdb Initialize package database."
                 echo "rpm --rebuilddb Rebuild package database."
                 echo
                 echo "*** For more help type: 'man $APP_NAME'"
                 echo "                        '$APP_NAME --help'"
                 echo
                 f_press_enter_key_to_continue
} # End of function f_rpm
#
# +----------------------------------------+
# |            Function f_synaptic         |
# +----------------------------------------+
#
f_synaptic () {
                 clear # Blank the screen.
                 echo "Synaptic - A GUI package manager and is in the menu for reference only."
                 echo
                 echo "However, like many GUI applications, it can be launched by from the CLI."
                 echo "Synaptic can be launched from the command line with the 'synaptic' command."
                 echo
                 f_press_enter_key_to_continue
} # End of function f_synaptic
#
# +----------------------------------------+
# |              Function f_yast           |
# +----------------------------------------+
#
f_yast () {
                 clear # Blank the screen.
                 echo "YaST - A GUI package manager and is in the menu for reference only."
                 echo
                 echo "However, like many GUI applications, it can be launched by from the CLI."
                 echo "YaST can be launched from the command line with the 'yast' command."
                 echo
                 f_press_enter_key_to_continue
} # End of function f_yast
#
# +----------------------------------------+
# |              Function f_yum            |
# +----------------------------------------+
#
f_yum () {
                 clear # Blank the screen.
                 echo "yum - 'Yellow Dog Updated' package manager."
                 echo
                 echo "Usage:"
                 echo "yum upgrade <package name> Upgrade/Install a package."
                 echo "yum -list <package name> Show package description and information."
                 echo "yum search <text> Searches package names, descriptions, summaries."
                 echo "yum provides <text> Searches files, packages providing a function."
                 echo "yum update Upgrade packages to latest versions."
                 echo "yum install <package name> Installs new software packages."
                 echo "yum groupinstall <application name> Installs new software packages."
                 echo "yum remove <package name> Uninstalls software packages."
                 echo
                 echo "*** For more help type: 'man $APP_NAME'"
                 echo "                        '$APP_NAME --help'"
                 echo
                 f_press_enter_key_to_continue
} # End of function f_yum
#
# +----------------------------------------+
# |             Function f_zypper          |
# +----------------------------------------+
#
f_zypper () {
                 clear # Blank the screen.
                 echo "zypper - Zypper package manager."
                 echo
                 echo "Usage:"
                 echo "zypper search -is List installed packages."
                 echo "zypper search -d <text> searches package names, descriptions, summaries."
                 echo "zypper update Upgrade packages to latest versions."
                 echo "zypper install <package name> Installs new software packages."
                 echo "zypper remove <package name> Uninstalls software packages."
                 echo "zypper refresh Refresh repository package information."
                 echo "zypper list-updates List updates available for installed packages."
                 echo "zypper dist-upgrade Upgrade kernel to next version."
                 echo
                 echo "*** For more help type: 'man $APP_NAME'"
                 echo "                        '$APP_NAME --help'"
                 echo
                 f_press_enter_key_to_continue
                 f_application_run
} # End of function f_zypper
#
