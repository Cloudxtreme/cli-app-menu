# Â©2013 Copyright 2013 Robert D. Chin
#
# +----------------------------------------+
# |             Revision Date              |
# +----------------------------------------+
# REVDATE="August-21-2013 02:01"
#
# +----------------------------------------+
# |      Function f_initvars_menu_app      |
# +----------------------------------------+
#
f_initvars_menu_app () {
      TCOLOR="black"
      ERROR=0        # Initialize to 0 to indicate success at running last
                     # command.
      APP_NAME=""    # Initialize to null. String variable contains
                     # application name.
      CHOICE_MAIN=-1 # Initialize to -1 to force until loop without exiting
                     # Main Menu.
      CHOICE_CAT=-1  # Initialize to -1 to force until loop without exiting
                     # Category Menu.
      CHOICE_SCAT=-1 # Initialize to -1 to force until loop without exiting 
                     # Sub-Category Menu.
      CHOICE_TCAT=-1 # Initialize to -1 to force until loop without exiting 
                     # 3rd-level Category Menu.
      CHOICE_APP=-1  # Initialize to -1 to force until loop without exiting 
                     # Applications Menu.
      PRESS_KEY=1    # Display "Press 'Enter' key to continue."
} # End of f_initvars_menu_app
#
# +----------------------------------------+
# |          Function f_show_menu          |
# +----------------------------------------+
#
#  Inputs: MENU_TITLE, DELIMITER, THIS_FILE, MAX.
# Outputs: MAX, XNUM.
#
f_show_menu () { # $1=$MENU_TITLE $2=$DELIMITER
      clear # Blank the screen.
      f_term_color # Set terminal color.
      echo "--- $MENU_TITLE ---"
      echo
      if [ $DELIMITER = "#AAA" ] ; then #AAA This 3rd field prevents awk from printing this line into menu options.
         echo "0 - Quit to command line prompt." # Option for Main Menu only.
      else
         echo "0 - Return to previous menu." # Option for all other sub-menus.
      fi
      #
      # Calculate $MAX, the number of menu items using grep -c(ount) option.
      # Count number of lines containing special comment marker string to get
      # maximum item number.
      #
      MAX=$(grep $DELIMITER -c $THIS_FILE)
      #
      # Subtract 1 since the line DELIMITER=<string> contains the 
      # special comment marker but is not part of menu display.
      #
      MAX=$((MAX=$MAX-1))
      #
      # Cannot use MAX=$MAX-1, since if MAX=12 echo $MAX shows "12-1" not "11".
      #
      # The following command awk '{<if condition>{print field}}
      # will print the menu items. The command automatically calculates the
      # menu option numbers for you.
      #
      # if statement conditional "($2&&!$3)":
      # Since the $DELIMITER is the special comment marker, then:
      # if there is 1 marker (2 fields) then awk will print the menu item.
      # if there are 2 markers (3 fields), then awk will not print anything.
      # This prevents the lines of code which set the $ DELIMITER variable from
      # being printed as a menu item, because they purposely have 2 markers.
      #
      # The menu option numbers are incremented using any unset variable name
      # (such as "XNUM") followed by "++",
      # However, because XNUM is unset, it will increment from zero, whereas we
      # want it to increment from one.
      # To do this, we add one before XNUM so the expression is now "1+XNUM++".
      # so numbering will always start at one. Interestingly the "++" increment
      # command is only valid from within awk.
      #
      awk -F $DELIMITER '{if ($2&&!$3){print 1+XNUM++" -"$2;}}' $THIS_FILE
      f_choice_array  # Create array to handle numeric answer to menu choices.
      #
      echo
      echo -n "Enter 0 to $MAX or letters: " # echo -n supresses line-feed.
} # End of function f_show_menu
#
# +----------------------------------------+
# |         Function f_choice_array        |
# +----------------------------------------+
#
#  Inputs: DELIMITER, THIS_FILE.
#    Uses: XNUM, XSTR
# Outputs: CHOICE[$XNUM]
#
f_choice_array () {
      # declare -A CHOICE  # Commented out; do not need to declare the array.
      unset CHOICE
      XNUM=1 # Initialize XNUM.
      X=" "
      #
      # 1. The 1st awk:
      #    if-statement conditional "($2&&!$3)":
      #    Since the $DELIMITER is the special comment marker, then:
      #    if there is 1 marker (2 fields) then awk will print the 2nd field.
      #    if there are 2 markers (3 fields), then awk will not print anything.
      #    This prevents the lines of code which set the $ DELIMITER variable
      #    from being printed as a menu item, since they have 2 markers.
      #
      # 2. The 2nd awk:
      #    Prints the name of the menu item but not the description.
      #
      # 3. The 3rd awk:
      #    If the name of the menu item is 2 or more words, just print the
      #    first 2 words into array CHOICE[$XNUM] which is sufficient for case
      #    pattern matching on that menu item choice.
      #    Allow app names consisting of 2 words. i.e. "ip addr", "ip route".

      #    The <space> between the words needs a substitution { print $1"%"$2 }
      #    of a "%" for the <space> so awk will not separate the words into 2
      #    different menu items, rather than 1 menu item having 2 words.
      # 
      for XSTR in `awk -F $DELIMITER '{ if ( $2&&!$3 ) { print $2 } }' $THIS_FILE | awk -F " - " '{ print $1 }' | awk '{ if ( $2 ) { print $1"%"$2 } else {print $1 } }'` # Use back-ticks to redirect, not single quotes.
      #
      # Set XSTR to first two words (delimited by "%" of menu choice name.
      # Example: Main menu item, "About CLI Menu" then XSTR="About%CLI" 
      do
           XSTR=${XSTR/[%]/ }    # Substitute <space> for "%" to restore name.
           CHOICE[$XNUM]=$XSTR   # 
           XNUM=`expr $XNUM + 1` # Use back-ticks to redirect, not single quotes.
      done
} # End of f_choice_array
#
# +----------------------------------------+
# |       Function f_common_scat_menu      |
# +----------------------------------------+
#
#  Inputs: CHOICE_SCAT.
# Outputs: CHOICE_SCAT.
#
f_common_scat_menu () {
#
      case $CHOICE_SCAT in
           # Quit?
           0)
           CHOICE_SCAT=0
           PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
           ;;
           [1-9] | [1-9][0-9])
           if [  $CHOICE_SCAT -ge 1 -a $CHOICE_SCAT -le $MAX ] ; then
              CHOICE_SCAT=${CHOICE[$CHOICE_SCAT]}
           fi
           ;;
           [Rr] | [Rr][Ee] | [Rr][Ee][Tt] | [Rr][Ee][Tt][Uu]*)
           CHOICE_SCAT=0
           PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
           ;;
      esac
} # End of function f_common_scat_menu
#
# +----------------------------------------+
# |       Function f_common_tcat_menu      |
# +----------------------------------------+
#
#  Inputs: CHOICE_TCAT, MAX, CHOICE[XNUM].
# Outputs: CHOICE_TCAT.
#
f_common_tcat_menu () {
#
      case $CHOICE_TCAT in
           # Quit?
           0)
           CHOICE_TCAT=0
           PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
           ;;
           [1-9] | [1-9][0-9])
           if [  $CHOICE_TCAT -ge 1 -a $CHOICE_TCAT -le $MAX ] ; then
              CHOICE_TCAT=${CHOICE[$CHOICE_TCAT]}
           fi
           ;;
           [Rr] | [Rr][Ee] | [Rr][Ee][Tt] | [Rr][Ee][Tt][Uu]*)
           CHOICE_TCAT=0
           PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
           ;;
      esac
} # End of function f_common_tcat_menu
#
# +----------------------------------------+
# |       Function f_common_app_menu       |
# +----------------------------------------+
#
#  Inputs: CHOICE_APP, MAX, CHOICE[XNUM].
# Outputs: CHOICE_APP.
f_common_app_menu () {
      case $CHOICE_APP in
           # Quit?
           0)
           CHOICE_APP=0
           PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
           ;;
           [1-9] | [1-9][0-9])
           if [  $CHOICE_APP -ge 1 -a $CHOICE_APP -le $MAX ] ; then
              CHOICE_APP=${CHOICE[$CHOICE_APP]}
           fi
           ;;
           [Rr] | [Rr][Ee] | [Rr][Ee][Tt] | [Rr][Ee][Tt][Uu]*)
           CHOICE_APP=0
           PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
           ;;
      esac
} # End of function f_common_app_menu
#
# +----------------------------------------+
# |   Function f_how_to_quit_application   |
# +----------------------------------------+
#
# Inputs: $1, $2, APP_NAME.
#
f_how_to_quit_application () { 
      # $1 typed key to quit. 
      # $2 string "no-clear" if screen should not be cleared.
      #
      if [ -z $2 ] ; then
      # if [ $2 != "no-clear" ] ; then
         clear # Blank the screen.
      fi
      echo
      echo "To quit $APP_NAME, type $1."
      f_press_enter_key_to_continue
} # End of function how_to_quit_application
#
# +----------------------------------------+
# |          Function f_term_color         |
# +----------------------------------------+
#
# Inputs: TCOLOR.
#
f_term_color () { # Set terminal display properties.
      case $TCOLOR in
           [Bb] | [Bb][Ll] | [Bb][Ll][Aa] | [Bb][Ll][Aa][Cc] | [Bb][Ll][Aa][Cc][Kk])
              setterm -reset -bold on
           ;;
           [Ww] | [Ww][Hh] | [Ww][Hh][Ii] | [Ww][Hh][Ii][Tt] | [Ww][Hh][Ii][Tt][Ee])
              setterm -reset
              setterm -foreground white -background black -inverse
           ;;  
      esac
} # End of function f_term_color
#
# +----------------------------------------+
# | Function f_press_enter_key_to_continue |
# +----------------------------------------+
#
# Inputs: None.
#
f_press_enter_key_to_continue () { # Display message and wait for user input.
      . lib_cli-common.lib
      echo
      echo -n "Press '"Enter"' key to continue."
      read ANS
} # End of function f_press_enter_key_to_continue
#
# +----------------------------------------+
# |   Function f_option_press_enter_key    |
# +----------------------------------------+
#
# Inputs: PRESS_KEY.
#
f_option_press_enter_key () { # Display message and wait for user input.
      # $PRESS_KEY = 0 means Do not display "Press 'Enter' key to continue."
      # $PRESS_KEY = 1 means Display "Press 'Enter' key to continue."
      #
      if [ $PRESS_KEY -eq 1 ] ; then
         f_press_enter_key_to_continue
      fi
} # End of function f_option_press_enter_key
#
# +----------------------------------------+
# |       Function f_application_help      |
# +----------------------------------------+
#
#  Inputs: CHOICE_APP, ERROR.
# Outputs: PRESS_KEY, CHOICE_APP=-1, APP_NAME
#
f_application_help () { # $CHOICE_APP="<Application name> --help"
                        # $CHOICE_APP="man <Application name>"
      case $CHOICE_APP in
           *--help)
              clear # Blank screen
              # awk extracts only the application's name to use for APP_NAME.
              APP_NAME=$(echo $CHOICE_APP | awk '{print $1;}')
              #
              # Test to see if the application is installed.
              command -v $APP_NAME
              ERROR=$? # Save error flag condition.
              # If there are no --help pages, ask user if wants to install app.
              # Function f_application_install needs APP_NAME as input
              #
              if [ $ERROR -ne 0 ] ; then
                 # Error code 1 $?=1 means no --help available.
                 # Error code 0 (zero) where $?=0 means no error.
                 echo "No '--help' option available for $APP_NAME."
                 echo
                 echo "This $APP_NAME application is either not installed"
                 echo "or is installed but help pages were never written for it."
                 echo
                 #
                 # Note: the $APP_NAME is not neccessarily the package name i.e. trek is in bsdgames package.
                 #
                 echo "To install under Debian-based Linux use command:"
                 echo "                           sudo apt-get install <application package name>" 
                 echo
                 echo "To install under Red Hat-based Linux use command:"
                 echo "                           sudo rpm -ivh <application package name>"
                 echo
                 echo "To install under Arch-bashed Linux use command:"
                 echo "                           sudo pacman -S <application package name>"
                 echo
                 echo "To install under Slackware-based Linux use command:"
                 echo "                           sudo installpkg <application package name>"
                 echo "                           sudo slackpkg <application package name>"
                 echo 
                 echo -n "Do you want to install $APP_NAME (y/N)? "
                 read ANS
                 case $ANS in # Start of Install Application Option case statement.
                      [Yy] | [Yy][Ee] | [Yy][Ee][Ss]) # Yes, install the application.
                      f_application_install
                      PRESS_KEY=1 # Display "Press 'Enter' key to continue."
                      ;;              
                      [Nn] | [Nn][Oo] | *) # No, do not install the application.
                      ERROR=0
                      PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
                      ;;
                 esac # End of Install Application Option case statement.
              else
                 $CHOICE_APP # Run <Application name> --help
                 PRESS_KEY=1 # Display "Press 'Enter' key to continue."
              fi
              CHOICE_APP=-1 # Force stay in menu until loop.
              # Convert string to integer -1. Also indicates valid menu choice.
              # If valid, f_bad_application_menu_choice will not force PRESS_KEY=1.
           ;;
           man' '*)
              clear # Blank screen
              $CHOICE_APP # CHOICE_APP = man <Application name>.
              ERROR=$? # Save error flag condition.
              # If there are no man pages, ask user if wants to install app.
              # Function f_application_install needs APP_NAME as input
              # awk extracts only the application's name to use for APP_NAME.
              APP_NAME=$(echo $CHOICE_APP | awk '{print $2;}')
              #
              PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
              #
              if [ $ERROR -ne 0 ] ; then
                 # Error code 16 where $?=16 means no man(ual) entry.
                 # Error code 0 (zero) where $?=0 means no error.
                 echo "No manual pages available for $APP_NAME."
                 echo
                 echo "This $APP_NAME application is either not installed"
                 echo "or is installed but man pages were never written for it."
                 echo
                 #
                 # Note the $APP_NAME is not neccessarily the package name i.e. trek is in bsdgames package.
                 #
                 echo "To install under Debian-based Linux use command:"
                 echo "                           sudo apt-get install <application package name>"
                 echo
                 echo "To install under Red Hat-based Linux use command:"
                 echo "                           sudo rpm -ivh <application package name>"
                 echo
                 echo "To install under Arch-based Linux use command:"
                 echo "                           sudo pacman -S <application package name>"
                 echo
                 echo "To install under Slackware-based Linux use command:"
                 echo "                           sudo installpkg <application package name>"
                 echo "                           sudo slackpkg <application package name>"
                 echo 
                 echo -n "Do you want to install $APP_NAME (y/N)? "
                 read ANS
                 case $ANS in # Start of Install Application Option case statement.
                      [Yy] | [Yy][Ee] | [Yy][Ee][Ss]) # Yes, install the application.
                      f_application_install
                      PRESS_KEY=1 # Display "Press 'Enter' key to continue."
                      ;;              
                      [Nn] | [Nn][Oo] | *) # No, do not install the application.
                      ERROR=0
                      PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
                      ;;
                 esac # End of Install Application Option case statement.
              fi
              CHOICE_APP=-1 # Force stay in menu until loop.
              # Convert string to integer -1. Also indicates valid menu choice.
              # If valid, f_bad_application_menu_choice will not force PRESS_KEY=1.
           ;;
      esac
#
} # End of function f_application_help
#
# +----------------------------------------+
# |       Function f_application_run       |
# +----------------------------------------+
#
#  Inputs: APP_NAME, INSTALL_ANS.
# Outputs: CHOICE_APP=-1.
#
f_application_run () {
      CHOICE_APP=-1 # Force stay in menu until loop.
      # Convert string to integer -1. Also indicates valid menu choice.
      # If valid, f_bad_application_menu_choice will not force PRESS_KEY=1.
      #
      clear # Blank the screen.
      #
      $APP_NAME # Run application.
      #
      ERROR=$? # Save error flag condition.
      case $ERROR in
           127)  # Error code 127 means application is not installed.
           f_application_error # installs application.
           # If user decided to install application.
           if [ $ERROR=127 -a $INSTALL_ANS="YES" ] ; then 
              $APP_NAME           # Run application.
              f_application_error # Check for errors.
                                  # If so, display appropriate error message.
           fi
           ;;
           1 | 13 | 62 | [!0]) # If any error [!0] occurs (error code is not zero).
           f_application_error # Display appropriate error message.
           ;;
      esac
     #
} # End of function f_application_run
#
# +----------------------------------------+
# | Function f_application_bad_menu_choice |
# +----------------------------------------+
#
#  Inputs: CHOICE_APP, APP_NAME.
# Outputs: CHOICE_APP, PRESS_KEY.
#
# Always set CHOICE_APP from string to an integer because menu until loop
# tests until [ CHOICE_APP -eq 0 ] and will error if CHOICE_APP is a string.
#
# Function f_application_run is always called before this function.
# If valid menu choice, f_application_run sets CHOICE_APP=-1 then leave alone.
# If CHOICE_APP=0 to quit menu, then leave alone.
# If invalid menu choice, CHOICE_APP is bad string or bad integer,
#    then set CHOICE_APP=-1 and do not display "Press 'Enter' key to continue."
#
f_application_bad_menu_choice () {
      case $CHOICE_APP in
           "")
           CHOICE_APP=-1 # Convert string to integer -1 forcing stay in until loop.
           PRESS_KEY=0   # Do not display "Press 'Enter' key to continue."
           ;;
           [A-Za-z]*)
           CHOICE_APP=-1 # Convert string to integer -1 forcing stay in until loop.
           PRESS_KEY=0   # Do not display "Press 'Enter' key to continue."
                         # Specifically for alpha nonsense responses.
           ;;
      esac
      if [ $CHOICE_APP -le -2 -o $CHOICE_APP -gt $MAX ] ; then
         CHOICE_APP=-1   # Convert string to integer -1 forcing stay in until loop.
         PRESS_KEY=0     # Do not display "Press 'Enter' key to continue."
                         # Specifically for out-of-bounds numeric response.
      fi
} # End of function f_application_bad_menu_choice
#
# +----------------------------------------+
# |    Function f_scat_bad_menu_choice     |
# +----------------------------------------+
#
#  Inputs: CHOICE_SCAT.
# Outputs: CHOICE_SCAT, PRESS_KEY.
#
f_scat_bad_menu_choice () {
      case $CHOICE_SCAT in
           "")
           CHOICE_APP=-1 # Convert string to integer -1 forcing stay in until loop.
           PRESS_KEY=0   # Do not display "Press 'Enter' key to continue."
           ;;
           [A-Za-z]*)
           CHOICE_SCAT=-1 # Convert string to integer -1 forcing stay in until loop.
           PRESS_KEY=0    # Do not display "Press 'Enter' key to continue."
                          # Specifically for alpha nonsense responses.
           ;;
      esac
      if [ $CHOICE_SCAT -le -2 -o $CHOICE_SCAT -gt $MAX ] ; then
         CHOICE_SCAT=-1   # Convert string to integer -1 forcing stay in until loop.
         PRESS_KEY=0      # Do not display "Press 'Enter' key to continue."
                          # Specifically for out-of-bounds numeric response.
      fi
} # End of function f_scat_bad_menu_choice
#
# +----------------------------------------+
# |    Function f_tcat_bad_menu_choice     |
# +----------------------------------------+
#
#  Inputs: CHOICE_TCAT.
# Outputs: CHOICE_TCAT, PRESS_KEY.
#
f_tcat_bad_menu_choice () {
      case $CHOICE_TCAT in
           "")
           CHOICE_APP=-1 # Convert string to integer -1 forcing stay in until loop.
           PRESS_KEY=0   # Do not display "Press 'Enter' key to continue."
           ;;
           [A-Za-z]*)
           CHOICE_TCAT=-1 # Convert string to integer -1 forcing stay in until loop.
           PRESS_KEY=0    # Do not display "Press 'Enter' key to continue."
                          # Specifically for alpha nonsense responses.
           ;;
      esac
      if [ $CHOICE_TCAT -le -2 -o $CHOICE_TCAT -gt $MAX ] ; then
         CHOICE_TCAT=-1   # Convert string to integer -1 forcing stay in until loop.
         PRESS_KEY=0      # Do not display "Press 'Enter' key to continue."
                          # Specifically for out-of-bounds numeric response.
      fi
} # End of function f_tcat_bad_menu_choice
#
# +----------------------------------------+
# |       Function f_application_error     |
# +----------------------------------------+
#
#  Inputs: ERROR, APP_NAME. 
# Outputs: CHOICE_MAIN, CHOICE_CAT, CHOICE_SCAT, CHOICE_APP, INSTALL_ANS
#          PRESS_KEY, APP_NAME_SUDO, APP_NAME_INSTALL, APP_NAME_TMP.
#
f_application_error () {
      if [ $ERROR -ne 0 ] ; then
         case $APPNAME in # Start of AppName case statement.
              sudo' '*)
              # Strip 'sudo', options and parameters from APP_NAME by using awk command.
              APP_NAME_TMP=$(echo $APP_NAME | awk '{print $2;}')
              ;;
              *)
              # If string APP_NAME/APP_NAME_INSTALL includes spaces for
              # run-time parameters, then just extract package name.
              # i.e. "dstat 1 10", then extract "dstat" as package name.
              # i.e. "dstat --version", then extract "dstat" as package name.
              APP_NAME_TMP=$(echo $APP_NAME | awk '{print $1;}')
              ;;
         esac             # End of AppName case statement.
         #
         # Be sure variable is set to redisplay current menu afterwards.
         CHOICE_MAIN=-1 # Initialize to -1 to force until loop
                        # without exiting Main Menu.
         CHOICE_CAT=-1  # Initialize to -1 to force until loop
                        # without exiting Category Menu.
         CHOICE_SCAT=-1 # Initialize to -1 to force until loop 
                        # without exiting Sub-Category Menu.
         CHOICE_TCAT=-1 # Initialize to -1 to force until loop 
                        # without exiting 3rd-level Category Menu.
         CHOICE_APP=-1  # Initialize to -1 to force until loop
                        # without exiting Applications Menu.
      fi
      #
      case $ERROR in # Start of Error Number case statement.
           2) # Error code 2 means operand or files is missing.
           # Display error message.
           f_display_error_code
           echo "Missing operand (file name(s) or names)."
           echo "Try running $APP_NAME_TMP again this time using operands."
           echo
           echo "Operands may be filenames as in the examples below."
           echo "Example: $APP_NAME_TMP <filename> or $APP_NAME_TMP <filename1> <filename2>"
           echo "Example: locate test1.txt     or diff test1.txt test2.txt"
           echo
           echo "Or operands may be a combination of parameters, options, and filenames."
           echo "Example: $APP_NAME_TMP <parameters> <filename> <options>"
           echo "Example: find /home -iname test1.txt -print"
           PRESS_KEY=1 # Display "Press 'Enter' key to continue."
           ;;
           127) # Error code 127 means application is not installed.
           # Display error message.
           f_display_error_code
           echo "This $APP_NAME_TMP application is not installed."
           echo
           echo -n "Do you want to install $APP_NAME_TMP (y/N)? "
           read INSTALL_ANS
           case $INSTALL_ANS in # Start of Install Application Option case statement.
                [Yy] | [Yy][Ee] | [Yy][Ee][Ss]) # Yes, install the application.
                INSTALL_ANS="YES"
                f_application_install
                PRESS_KEY=1 # Display "Press 'Enter' key to continue."
                ;;              
                [Nn] | [Nn][Oo] | *) # No, do not install the application.
                INSTALL_ANS="NO"
                ERROR=0
                PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
                ;;
           esac # End of Install Application Option case statement.
           ;;
           1) # Error code 1 is a general error code. But it does not always mean there actually was an error.
              # Some applications exit with error code 1 even if successfully run.
              # The Error Code 1 Number Exceptions case statement, takes care of those weird applications.
           case $APP_NAME in # Start of Error Code Number 1 Exceptions case statement.
                *diff*)
                # Do not display error message if error code 1
                # and apps colordiff, diff, imediff2, vimdiff, wdiff.
                # For diff apps, error code 1 means compared files are different, not a real error.
                ;;
                sudo' '*)
                # Display error message.
                f_display_error_code
                echo
                echo "Try running $APP_NAME_TMP without the sudo command."
                echo "There is a possibility that the application is not installed."
                PRESS_KEY=1 # Display "Press 'Enter' key to continue."
                ;;
                *)
                # Display error message.
                f_display_error_code
                echo "Run $APP_NAME again this time using sudo?"
                echo -n "Use sudo (temporary root permissions) (y/N)? "
                read ANS
                case $ANS in  # Start of Use SUDO case statement.
                     [Yy] | [Yy][Ee] | [Yy][Ee][Ss])
                     APP_NAME_SUDO=$APP_NAME # Don't modify APP_NAME
                     sudo $APP_NAME_SUDO
                     ERROR=$? # Save error flag condition.
                     #
                     if [ $ERROR -ne 0 ] ; then # Error after running with sudo?
                        # Error code 1 $?=1 means sudo failed.
                        # Error code 0 (zero) where $?=0 means no error.
                        #
                        # Display error message.
                        f_display_error_code
                        echo "Running sudo $APP_NAME_SUDO failed."
                        echo "May be caused by bad sudo password, or user has no permission to use sudo,"
                        echo "or bad $APP_NAME_TMP syntax."
                        echo "Consult help using man $APP_NAME_TMP."
                        echo
                     fi
                     PRESS_KEY=1 # Display "Press 'Enter' key to continue."
                     ;;
                     [Nn] | [Nn][Oo] | *)
                     ERROR=0
                     PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
                     ;;
                esac     # End of Use SUDO case statement.
                ;;
           esac              # End of Error Code Number 1 Exceptions case statement.
           ;;
           13 | 62 | [!0]) 
           # 13-some unknown app?
           # 62-"command not found" freshclam log folders not set up.
           # [!0]-not zero, any non-zero error number.
           case $APP_NAME in  # Start of sudo-error case statement
                sudo' '*)
                # Display error message.
                f_display_error_code
                echo
                echo "Try running $APP_NAME_TMP without the sudo command."
                echo "There is a possibility that the application is not installed."
                PRESS_KEY=1 # Display "Press 'Enter' key to continue."
                ;;
                *)
                # Display error message.
                f_display_error_code
                echo
                echo "Run $APP_NAME again this time using sudo?"
                echo -n "Use sudo (temporary root permissions) (y/N)? "
                read ANS
                case $ANS in  # Start of Use SUDO case statement.
                     [Yy] | [Yy][Ee] | [Yy][Ee][Ss])
                     APP_NAME_SUDO=$APP_NAME # Don't modify APP_NAME
                     sudo $APP_NAME_SUDO
                     ERROR=$? # Save error flag condition.
                     #
                     if [ $ERROR -ne 0 ] ; then # Error after running with sudo?
                        # Error code 1 $?=1 means sudo failed.
                        # Error code 0 (zero) where $?=0 means no error.
                        #
                        # Display error message.
                        f_display_error_code
                        echo "Running sudo $APP_NAME_SUDO failed."
                        echo "May be caused by bad sudo password, or user has no permission to use sudo,"
                        echo "or bad $APP_NAME_TMP syntax."
                        echo "Consult help using man $APP_NAME_TMP."
                        echo
                     fi
                     PRESS_KEY=1 # Display "Press 'Enter' key to continue."
                     ;;
                     [Nn] | [Nn][Oo] | *)
                     ERROR=0
                     PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
                     ;;
                esac     # End of Use SUDO case statement.
                ;;
           esac   # End of sudo-error case statement
           ;;
      esac # End of Error Number case statement.
      # This function needs to be followed by a f_press_enter_key_to_continue 
      # or by a f_option_press_enter_key so that messages are displayed.
} # End of function f_application_error
#
# +----------------------------------------+
# |     Function f_display_error_code      |
# +----------------------------------------+
#
#  Inputs: ERROR, APP_NAME_TMP. 
# Outputs: None.
#
f_display_error_code () {
      echo
      echo "**********************************************************************"
      echo ">>>>>>>>>> SEE ABOVE for application error messages, if any <<<<<<<<<<"
      echo "**********************************************************************"
      echo
      echo "          ***********"
      echo "Error code >>> $ERROR <<<  from $APP_NAME_TMP application."
      echo "          ***********"
      echo
} # End of function f_display_error_code
#
# +----------------------------------------+
# |     Function f_application_install     |
# +----------------------------------------+
#
#  Inputs: ERROR, APP_NAME. 
# Outputs: APP_NAME_INSTALL.
#
f_application_install () {
      APP_NAME_INSTALL=$APP_NAME 
      # Default of APP_NAME_INSTALL is simply APP_NAME. 
      # This may be modified below in the Installation Package Name
      # case statement.
      #
      case $APP_NAME_INSTALL in # Start of APP_NAME_INSTALL case statement.
           *' '*)  
           # If string APP_NAME/APP_NAME_INSTALL includes spaces for
           # run-time parameters, then just extract package name.
           # i.e. "dstat 1 10", then extract "dstat" as package name.
           # i.e. "dstat --version", then extract "dstat" as package name.
           #
           APP_NAME_INSTALL=$(echo $APP_NAME_INSTALL | awk '{print $1;}')
           ;;
      esac                      # End of APP_NAME_INSTALL case statement.
      #
      # Below are cases where the APP_NAME is not the same as the
      # package name used to install the application.
      # i.e. The game 'trek' is installed using the package called 'bsdgames'.
      #
      case $APP_NAME_INSTALL in # Start of Install Package Name case statement.
           acat| als | apack | atool | aunpack)
           APP_NAME_INSTALL="atool"
           ;;
           aria2c)
           APP_NAME_INSTALL="aria2"
           ;;
           barnowl | zcrypt)
           APP_NAME_INSTALL="barnowl"
           ;;
           adventure | arithmetic | atc | backgammon | battlestar | bcd | boggle | caesar | canfield | countmail | cribbage | dab | go-fish | gomoku | hack | hangman | hunt | mille | monop | morse | number | pig | phantasia | pom | ppt | primes | quiz | random | rain | robots | rot13 | sail | snake | tetris | trek | wargames | worm | worms | wump | wtf)
           APP_NAME_INSTALL="bsdgames"
           ;;
           clamscan)
           APP_NAME_INSTALL="clamav"
           ;;
           todo)
           APP_NAME_INSTALL="devtodo"
           ;;
           fbgs)
           APP_NAME_INSTALL="fbi"
           ;;
           glances) # Add repository for glances application.
           sudo add-apt-repository ppa:arnaud-hartmann/glances-stable
           sudo apt-get update
           ;;
           ifplugstatus)
           APP_NAME_INSTALL="ifplugd"
           ;;
           animate | composite | compare | conjure | convert | display | identify | import | mogrify | montage | stream)
           APP_NAME_INSTALL="imagemagick"
           ;;
           moc)
           APP_NAME_INSTALL="libqt4-dev"
           ;;
           lynx)
           APP_NAME_INSTALL="lynx-cur"
           ;;
           nagios3)
           APP_NAME_INSTALL="nagios3-core"
           ;;
           tcpblast | netload | trafshow | netwatch | strobe | statnet | tcpspray)
           APP_NAME_INSTALL="netdiag"
           ;; 
           mpstat | iostat | pidstat | sadf | sar)
           APP_NAME_INSTALL="sysstat"
           ;;
           photorec)
           APP_NAME_INSTALL="testdisk"
           ;;
           aaxine | cacaxine | fbxine)
           APP_NAME_INSTALL="xine-console"
           ;;
           xz | unxz | xzcat | xzgrep)
           APP_NAME_INSTALL="xz-utils"
           ;;
      esac # End of Install Package Name case statement.
      #
      if [ -d /etc/apt ] ; then 
         # if /etc/apt directory exists, then use apt-get install
         # for Debian-based packages.
         sudo apt-get install $APP_NAME_INSTALL
         ERROR=$? # Save error flag condition.
         if [ $ERROR -ne 0 ] ; then
            # Error code 1 $?=1 means installation failed. Error code 0 (zero) where $?=0 means no error.
            echo
            echo "Installation of $APP_NAME_INSTALL failed."
            echo "Command sudo apt-get install $APP_NAME_INSTALL failed."
            echo "Perhaps the software package $APP_NAME_INSTALL"
            echo "is not available for this linux distribution."
            echo
            f_application_web_install
         fi
         #
      elif [ -d /var/lib/slackpkg ] ; then
         # if <slackware linux installation directory> exists, then use slackpkg or installpkg 
         # for slackware packages.
         sudo slackpkg install $APP_NAME_INSTALL
         ERROR=$? # Save error flag condition.
         # 
         # 
         # This if statement is commented out because slackpkg has error code $?=0 even
         # if install fails.
         # 
         # COMMENTED OUT FOR SLACKPKG BECAUSE ERROR CODE IS ALWAYS 0 WHETHER OR NOT IT 
         # INSTALLED OK.
         #
         # To Do List: find a way to indicate a failed install and alter if statement below.
         #
         #if [ $ERROR -ne 0 ] ; then
         #   # Error code 1 $?=1 means installation failed.
         #   # Error code 0 (zero) where $?=0 means no error.
         #   echo
         #   echo "Installation of $APP_NAME_INSTALL failed."
         #   echo "Command sudo slackpkg $APP_NAME_INSTALL failed."
         #   echo "Perhaps the software package $APP_NAME_INSTALL"
         #   echo "is not available for this linux distribution."
         #   echo
         #   f_application_web_install
         #fi
         #
      elif [ -d /var/lib/pacman ] ; then
         # if <arch linux installation directory> exists, then use pacman
         # for arch linux packages.
         sudo pacman -S $APP_NAME_INSTALL
         ERROR=$? # Save error flag condition.
         if [ $ERROR -ne 0 ] ; then
            # Error code 1 $?=1 means installation failed.
            # Error code 0 (zero) where $?=0 means no error.
            echo
            echo "Installation of $APP_NAME_INSTALL failed."
            echo "Command sudo pacman -S $APP_NAME_INSTALL failed."
            echo "Perhaps the software package $APP_NAME_INSTALL"
            echo "is not available for this linux distribution."

            echo
            f_application_web_install
         fi
         #
         # rpm is last because some Slackware-based distros have rpm directories also.
      elif [ -d /var/lib/rpm ] ; then 
         # if /var/lib/rpm directory exists, then use rpm install
         # for RPM-based packages.
         sudo rpm -ivh $APP_NAME_INSTALL 
         # Assume if not Debian, then Red Hat distro packages.
         ERROR=$? # Save error flag condition.
         if [ $ERROR -ne 0 ] ; then
            # Error code 1 $?=1 means installation failed.
            # Error code 0 (zero) where $?=0 means no error.
            echo
            echo "Installation of $APP_NAME_INSTALL failed."
            echo "Command sudo rpm -ivh $APP_NAME_INSTALL failed."
            echo "Perhaps the software package $APP_NAME_INSTALL"
            echo "is not available for this linux distribution."
            echo
            f_application_web_install
         fi
      else
         echo
         echo "You will have to install the $APP_NAME_INSTALL package manually."
         echo "Automatic install is only available for apt, rpm, slackpkg, pacman package managers."
         f_press_enter_key_to_continue
      fi
      #
} # End of function f_application_install
#
# +----------------------------------------+
# | Function f_application_web_install     |
# +----------------------------------------+
#
#  Inputs: APP_NAME_INSTALL.
#    Uses: WEB_SITE_INSTALL
#
f_application_web_install () {
      WEB_SITE_INSTALL=""
      case $APP_NAME_INSTALL in # Start of Web Site case statement.
      asciiaquarium)
      WEB_SITE_INSTALL="http://www.robobunny.com/projects/asciiquarium/html/"
      ;;
      binary-clock)
      WEB_SITE_INSTALL="http://sourceforge.net/projects/binary-clock/files/binary-clock-src/binary-clock-0.5/binary-clock-0.5.tar.gz/download?use_mirror=iweb&download="
      ;;
      cclock)
      WEB_SITE_INSTALL="http://sourceforge.net/projects/cclock/files/latest/download"
      ;;
      clcal)
      WEB_SITE_INSTALL="http://www.hyborian.demon.co.uk/clcal/download.html"
      ;;
      clockywock)
      WEB_SITE_INSTALL="http://soomka.com/"
      ;;
      desmume)
      WEB_SITE_INSTALL="http://sourceforge.net/projects/desmume/files/desmume/"
      ;;
      edbrowse)
      WEB_SITE_INSTALL="http://the-brannons.com/edbrowse/"
      ;;
      fbv)
      WEB_SITE_INSTALL="http://freecode.com/projects/fbv"
      ;;
      grandfatherclock)
      WEB_SITE_INSTALL="http://freecode.com/projects/grandfatherclock"
      ;;
      handbrake-cli)
      WEB_SITE_INSTALL="http://handbrake.fr/downloads2.php"
      ;;
      herrie)
      WEB_SITE_INSTALL="http://herrie.info/#obtaining"
      ;;
      jed)
      WEB_SITE_INSTALL="http://www.jedsoft.org/jed/download.html"
      ;;
      jfbview)
      WEB_SITE_INSTALL="https://github.com/jichuan89/JFBView.git"
      ;;
      lnav)
      WEB_SITE_INSTALL="http://tstack.github.io/lnav/"
      ;;
      mencal)
      WEB_SITE_INSTALL="http://kyberdigi.cz/projects/mencal/index.php?l=en"
      ;;
      opencubicplayer)
      WEB_SITE_INSTALL="http://stian.cubic.org/project-ocp.php"
      ;;
      retawq)
      WEB_SITE_INSTALL="http://sourceforge.net/projects/retawq/files/retawq/retawq-0.2.6c/retawq-0.2.6c.tar.gz/download?use_mirror=hivelocity"
      ;;
      portbunny)
      WEB_SITE_INSTALL="http://portbunny.recurity.com/"
      ;;
      vtclock)
      WEB_SITE_INSTALL="http://webonastick.com/vtclock/"
      ;;
      yougrabber)
      WEB_SITE_INSTALL="http://sourceforge.net/projects/yougrabber/files/"
      ;;
      esac                      # End of Web Site case statement.
      #
      case $WEB_SITE_INSTALL in # Start of Web Install case statement.
      "")
      ;;
      *) # if web site is specified, then go there.
         echo
         echo "If application did not install properly, do want to use the w3m web browser"
         echo -n "to visit the project's web site to download manually (y/N)? "
         read ANS
         case $ANS in        # Start of Install case statement.
              [Yy] | [Yy][Ee] | [Yy][Ee][Ss])
              APP_NAME="w3m $WEB_SITE_INSTALL"
              f_how_to_quit_application "q"
              f_application_run
              ;;
              [Nn] | [Nn][Oo])
              ;;
         esac                # End of Install case statement.
      ;;
      esac                         # End of Web Install case statement.
} # End of function f_application_web_install
#
# +----------------------------------------+
# |  Function f_load_module                |
# +----------------------------------------+
#
#  Inputs: MOD_FILE
#    Uses: ANS, WEB_SITE.
# Outputs: ANS, WEB_SITE, PRESS_KEY
#
f_load_module () {
      PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
      #
      if [ -r $MOD_FILE ] ; then
         . $MOD_FILE # Invoke module library. # $MOD_FILE exists in current directory so use it.
      else
         echo -n "Download module library from which branch? (STABLE/testing/quit): "
         read ANS
         case $ANS in
              [Qq] | [Qq][Uu] | [Qq][Uu][Ii] | [Qq][Uu][Ii][Tt])
              PRESS_KEY=0 # Do not display "Press 'Enter' key to continue."
              ;;
              [Tt] | [Tt][Ee] | [Tt][Ee][Ss]*)
              WEB_SITE="https://raw.github.com/rdchin/CLI-app-menu/testing/$MOD_FILE"
              wget $WEB_SITE
              ANS="TESTING"
              echo "Downloaded files from github $ANS branch." 
              echo "Downloaded files are in the same folder as this script."
              echo
              . $MOD_FILE # Invoke module library. # $MOD_FILE exists in current directory so use it.
              PRESS_KEY=1 # Display "Press 'Enter' key to continue."
              ;;                  
              "" | [Ss] | [Ss][Tt] | [Ss][Tt][Aa]*)  
              WEB_SITE="https://raw.github.com/rdchin/CLI-app-menu/stable/$MOD_FILE"
              wget $WEB_SITE
              ANS="STABLE"
              echo "Downloaded files from github $ANS branch." 
              echo "Downloaded files are in the same folder as this script."
              echo
              . $MOD_FILE # Invoke module library. # $MOD_FILE exists in current directory so use it.
              PRESS_KEY=1 # Display "Press 'Enter' key to continue."
              ;;
           esac
      fi
      f_option_press_enter_key 
} # End of f_load_module
#
# +----------------------------------------+
# |       Function f_create_LIST_APPS      |
# +----------------------------------------+
#
#  Inputs: None
#    Uses: MOD_FILE, XSTR
# Outputs: File LIST_APPS
#
# File LIST_APPS may be recreated at any time from the command line.
# Prerequisite: ALL module files, mod_apps-*.lib MUST BE in the same directory
#               as this lib_cli-common.lib file.
#
# Type this command (without the double-quote marks) at the command line prompt:
# ". lib_cli-common.lib; f_create_LIST_APPS"
#  <dot><space>lib_cli-common.lib<semi-colon><space>f_create_LIST_APPS.
#
f_create_LIST_APPS () {
      # Generate file LIST_APPS by using grep on each module file.
      # Assumes all module files are present in current directory.
      if [ -r LIST_APPS ] ; then
         rm LIST_APPS # Remove old LIST_APPS file.
      fi
      #
      # Explanation of the "for XSTR in" loop:
      #
      # 1. grep [#]:M[A-Z][A-Z] README
      #    Find all lines matching "#:M[A-Z][A-Z]" in the file README.
      #    This will find strings like "#:MAA - Accounting Applications Menu"
      #
      # 2. awk '{print $1}'
      #    Prints just the Special Menu Item Marker, "#:MAA" and XSTR="#:MAA".
      #
      # 3. grep $XSTR README
      #    Search README for all occurrences of the Special Menu Item Marker.
      #    Find all lines matching "#:MAA" in the file README.
      #    This will find strings like "#:MAA - Accounting Applications Menu"
      #
      # 4. awk -F " - " '{print $2}'
      #    Strips the ":#MAA - " from it: "Accounting Applications Menu"
      #
      # 6. awk '{sub("Menu","Menu ***"); print $0}'
      #    Appends "***" at the end: "Accounting Applications Menu ***"
      #
      # Set XSTR to the Special Menu Item Marker.
      for XSTR in $(grep [#]:M[A-Z][A-Z] README | awk '{print $1}')
      # for XSTR in $(grep [#]:M[A-Z][A-Z] README | awk '{print $1}' | awk -F "#:" '{print $2}')
      do
          echo >> LIST_APPS
          # Print application category menu title.
          echo "________________________________________________" >> LIST_APPS
          echo -n "*** " >> LIST_APPS
          grep $XSTR README | awk -F " - " '{print $2}'  | awk '{sub("Menu","Menu ***"); print $0}' >> LIST_APPS
          #
          # Explanation of the "for MOD_FILE in" loop.
          #
          # 1. grep $XSTR $MOD_FILE
          #    Search the files mod_apps-*.lib one at a time for the Special
          #    Menu Item Marker.
          #    Find all lines matching "#MAA " in the files.
          #    This will find strings like:
          #    "#MAA ledger        - Ledger using double-entry."
          #
          # 2. awk -F $XSTR '{if ($2&&!$3){print $2}}' 
          #    awk -F "#M" '{if ($2&&!$3){print $2}}'
          #    if-statement conditional "($2&&!$3)":
          #    Since the $DELIMITER is part/all of the special comment marker,
          #    if there is 1 marker (2 fields) then print the 2nd field.
          #    if there are 2 markers (3 fields), then do not print anything.
          #    This prevents the lines of code which set the $ DELIMITER
          #    variable from being printed as a menu item, because they
          #    purposely have 2 markers.
          #    This will result in:
          #    " ledger        - Ledger using double-entry." w/delimiter $XSTR.
          #    "AA ledger        - Ledger using double-entry." w/delimiter #M.
          #
          # 3. awk '{sub(/[^" "]+ /, ""); print $0}'
          #    Substitute space for null at beginning of line.
          #    This will result in:
          #    "ledger        - Ledger using double-entry." w/delimiter "#M".
          #
          # Set XSTR from "#:MPS" to "#MPS" Special Menu Item Marker.
          # XSTR="#:MPS" to grep README file for menu titles.
          # XSTR="#MPS"  to grep mod_apps*.lib files for application names
          #              and descriptions.
          # XSTR="MPS"   almost worked but README contained the word "MUMPS"
          #              which caused problems when displaying the menu title
          #              for "#:MPS - PDF-PS Applications Menu". Too much time.
          # So somehow XSTR had to be modified within the for-loop.
          #
          XSTR=${XSTR/:/} # Use string substitution, I just learned how, cool!
          #
          # Print application names and descriptions.
          # Any new mod_apps*.lib files added must be included in the for-loop below.

          for MOD_FILE in mod_apps-audio.lib mod_apps-education.lib mod_apps-filedir.lib mod_apps-games.lib mod_apps-image.lib mod_apps-internet.lib mod_apps-network.lib mod_apps-office.lib mod_apps-screensaver.lib mod_apps-system.lib mod_apps-video.lib
          do
              # Human readable list without special comment markers.
              # Indents one space before application name.
              grep $XSTR $MOD_FILE | awk -F $XSTR '{if ($2&&!$3){print $2}}'  >> LIST_APPS
              #
              # Leaves no space before application name.
              # grep $XSTR $MOD_FILE | awk -F "#M" '{if ($2&&!$3){print $2}}' | awk '{sub(/[^" "]+ /, ""); print $0}' >> LIST_APPS

          done
      done
} # End of function f_create_LIST_APPS
#
